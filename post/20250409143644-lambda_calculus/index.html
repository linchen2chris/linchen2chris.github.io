<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Lambda 演算 - Even - A super concise theme for Hugo</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="[Lin Chen]"><meta name=description content="什么是 lambda 演算 \(\lambda\) 演算（Lambda Calculus）是一种形式体系，它仅通过函数定义（抽象化）与函数应用这两种极为简单的操作来表达计算。它虽然简单，却是图灵完备的，可以模型化任何计算，并构成了函数式编程语言的理论基础。
"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.150.1 with theme even"><link rel=canonical href=http://localhost:1313/post/20250409143644-lambda_calculus/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/sass/main.min.c972b5331cb58c1c1f2f5af18633a148f4d7b86c947a09d03611ce2e0e9f3698.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:url" content="http://localhost:1313/post/20250409143644-lambda_calculus/"><meta property="og:site_name" content="Even - A super concise theme for Hugo"><meta property="og:title" content="Lambda 演算"><meta property="og:description" content="什么是 lambda 演算 \(\lambda\) 演算（Lambda Calculus）是一种形式体系，它仅通过函数定义（抽象化）与函数应用这两种极为简单的操作来表达计算。它虽然简单，却是图灵完备的，可以模型化任何计算，并构成了函数式编程语言的理论基础。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-04-09T16:36:28+08:00"><meta property="article:modified_time" content="2025-04-09T16:36:33+08:00"><meta itemprop=name content="Lambda 演算"><meta itemprop=description content="什么是 lambda 演算 \(\lambda\) 演算（Lambda Calculus）是一种形式体系，它仅通过函数定义（抽象化）与函数应用这两种极为简单的操作来表达计算。它虽然简单，却是图灵完备的，可以模型化任何计算，并构成了函数式编程语言的理论基础。"><meta itemprop=datePublished content="2025-04-09T16:36:28+08:00"><meta itemprop=dateModified content="2025-04-09T16:36:33+08:00"><meta itemprop=wordCount content="1545"><meta itemprop=keywords content="函数式"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lambda 演算"><meta name=twitter:description content="什么是 lambda 演算 \(\lambda\) 演算（Lambda Calculus）是一种形式体系，它仅通过函数定义（抽象化）与函数应用这两种极为简单的操作来表达计算。它虽然简单，却是图灵完备的，可以模型化任何计算，并构成了函数式编程语言的理论基础。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Lin Chen</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/ox-hugo/><li class=mobile-menu-item>resource</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Lin Chen</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/ox-hugo/>resource</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Lambda 演算</h1><div class=post-meta><span class=post-time>2025-04-09</span><div class=post-category><a href=/categories/%E5%87%BD%E6%95%B0%E5%BC%8F/>函数式</a></div><span class=more-meta>1545 words </span><span class=more-meta>4 mins read </span><span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> times read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#什么是-lambda-演算>什么是 lambda 演算</a></li><li><a href=#形式语言>形式语言</a></li><li><a href=#推论规则>推论规则</a><ul><li><a href=#α转换--alpha-conversion>α转换 (Alpha Conversion)</a></li><li><a href=#β归约--beta-reduction>β归约 (Beta Reduction)</a></li><li><a href=#η转换--eta-conversion>η转换 (Eta Conversion)</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-outdated><div class=hint><p>[NOTE] Updated <span class=timeago datetime=2025-04-09T16:36:33 title="April 9, 2025">April 9, 2025</span>. This article may have outdated content or subject matter.</p></div></div><div class=post-content><h2 id=什么是-lambda-演算>什么是 lambda 演算</h2><p>\(\lambda\) 演算（Lambda Calculus）是一种形式体系，它仅通过函数定义（抽象化）与函数应用这两种极为简单的操作来表达计算。它虽然简单，却是图灵完备的，可以模型化任何计算，并构成了函数式编程语言的理论基础。</p><blockquote><p>PS: 什么是形式系统?</p><p>形式系统是一个使用精确定义的符号、规则和公理来研究推理和计算的数学或逻辑框架。</p><p>它通常包括：</p><ol><li><strong>形式语言</strong>: 一套符号（字母表）和形成合式公式（句子）的规则（语法）。</li><li><strong>公理</strong>: 一组被假定为真的初始公式。</li><li><strong>推论规则</strong>: 从公理或其他已被证明的公式推导出新公式（定理）的规则。</li></ol><p>形式系统旨在消除歧义，使推理过程完全形式化和机械化。</p></blockquote><h2 id=形式语言>形式语言</h2><p>Lambda Calculus 的形式语言（语法）非常简单，只包含三种基本构造：</p><ol><li><p><strong>变量 (Variable):</strong> 一个标识符，例如 <code>x</code>, <code>y</code>, <code>z</code> 。</p><ul><li>例子: <code>x</code></li></ul></li><li><p><strong>抽象 (Abstraction):</strong> 定义一个匿名函数，形式为 <code>λ&lt;变量>. &lt;项></code> 。读作 &ldquo;lambda &lt;变量> 点 &lt;项>&rdquo; 。</p><ul><li>例子: <code>λx. x</code> (这是一个接收参数 <code>x</code> 并返回 <code>x</code> 的函数，即恒等函数 identity function)。</li><li>例子: <code>λy. z</code> (这是一个接收参数 <code>y</code> 但总是返回 <code>z</code> 的函数，即常数函数)。</li><li>js 例子: <code>x => x+1</code></li></ul></li><li><p><strong>应用 (Application):</strong> 将一个函数应用于一个参数，形式为 <code>(&lt;项1> &lt;项2>)</code> 。 <code>项1</code> 通常是函数， <code>项2</code> 是参数。括号有时可省略。</p><ul><li>例子: <code>(λx. x) y</code> (将恒等函数 <code>λx. x</code> 应用于参数 <code>y</code>)。根据计算规则，这会化简为 <code>y</code></li><li>例子: <code>f x</code> (如果 <code>f</code> 是函数， <code>x</code> 是参数，这是 <code>(f x)</code> 的简写)。</li><li>例子: <code>(λf. λx. f (f x)) (λy. y)</code> (将一个“应用两次”的函数 <code>λf. λx. f (f x)</code> 应用于恒等函数 <code>λy. y</code>)。</li><li>js 例子: <code>(x => x + 1)(4)</code></li></ul></li></ol><p>任何合法的 Lambda Calculus 表达式（称为 lambda 项）都是由这三种基本构造组合而成的。</p><h2 id=推论规则>推论规则</h2><p>严格来说，Lambda演算与其说是一个公理系统，不如说是一个基于项重写规则的计算模型。其核心规则如下：</p><ol><li><strong>α转换 (alpha-conversion)</strong> ：可以更改约束变量的名称（例：λx.x 与 λy.y 等价）。</li><li><strong>β归约 (beta-reduction)</strong> ：对函数应用进行求值（例：(λx.M) N 可重写为 M[x/N]，即将 M 中的 x 替换为 N）。</li><li><strong>η转换 (eta-conversion)</strong> ：表示函数的外延性（例：如果 x 在 M 中不是自由出现，则 λx.(M x) 与 M 等价）。</li></ol><p>这些规则构成了定义 Lambda 项（表达式）等价性的基础。</p><h3 id=α转换--alpha-conversion>α转换 (Alpha Conversion)</h3><ul><li><strong>核心思想</strong> ：重命名绑定变量。</li><li><strong>目的</strong> ：避免变量名冲突，它声明了绑定变量的具体名称是不重要的。只要不引起歧义（比如新名称与自由变量冲突），可以随意更改 λ 抽象中绑定的变量名及其在函数体内的所有对应引用。</li><li><strong>例子</strong> ： <code>λx.x</code> 和 <code>λy.y</code> 是 α-等价的。 <code>λx.(λy. x y)</code> 可以 α-转换为 <code>λz.(λy. z y)</code> 。</li><li><strong>js 例子</strong> ： <code>x => x+1</code> 和 <code>y => y+1</code> 完全等价</li></ul><h3 id=β归约--beta-reduction>β归约 (Beta Reduction)</h3><ul><li><strong>核心思想</strong> ：函数应用（执行计算）。</li><li><strong>目的</strong> ：这是 Lambda 演算中最核心的计算规则。当一个 λ 抽象（函数）被应用到一个参数上时，将函数体中所有与 λ 绑定变量同名的*自由*变量替换为该参数。</li><li><strong>规则</strong> ： <code>(λx.M) N</code> β-归约为 <code>M[x/N]</code> （表示 M 中所有 x 被 N 替换）。</li><li><strong>例子</strong> ： <code>(λx.x + 1) 5</code> β-归约为 <code>5 + 1=。=(λx.λy. x) z</code> β-归约为 <code>λy. z</code> 。需要注意避免变量捕获（Variable Capture），必要时先进行 α 转换。</li><li><strong>js 例子</strong> ： <code>(x => x + x + 1)(5) -> 5 + 5 + 1</code> 或者 <code>(x => y => x + y) (5) -> y => 5 + y</code></li></ul><h3 id=η转换--eta-conversion>η转换 (Eta Conversion)</h3><ul><li><strong>核心思想</strong> ：函数外延性（Extensionality）或简化。</li><li><strong>目的</strong> ：它关联了一个函数与其“接收一个参数并立即应用该参数”的版本。如果一个函数 <code>f</code> 和另一个函数 <code>g</code> 对于所有可能的输入 <code>x</code> 都有 <code>f x = g x=，那么 =f</code> 和 <code>g</code> 是 η-等价的。</li><li><strong>规则 (η-归约)</strong> ： <code>λx.(M x)</code> 可以 η-归约为 <code>M=，前提是 =x</code> 在 <code>M</code> 中*不是自由变量*。这是一种简化形式。 js: <code>x => add(x) -> add</code></li><li><strong>规则 (η-展开)</strong> ： <code>M</code> 可以 η-展开为 <code>λx.(M x)=，前提是 =x</code> 在 <code>M</code> 中不是自由变量。 js: <code>add -> x => add(x)</code></li><li><strong>例子</strong> ： <code>λx.(concat "hello" x)</code> η-等价于 <code>concat "hello"</code> （假设 <code>x</code> 不在 <code>concat "hello"</code> 这个表达式或其定义中自由出现）。</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>[Lin Chen]</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2025-04-09
<a href=/commit/93d092e274f3a8f152b48605f3a18f94cd061d15 title="update format">(93d092e)</a></span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>Reward</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=/wechat.JPG>
<span>wechat</span>
</label><label class=qr-code-image for=reward><img class=image src=/alipay.JPG>
<span>alipay</span></label></div></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/20250410140746-sap/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">AWS SAP考试学习笔记</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/2024-booklist/><span class="next-text nav-default">2024书单</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js crossorigin=anonymous></script><script type=text/javascript>var gitalk=new Gitalk({id:"2025-04-09 16:36:28 +0800 +0800",title:"Lambda 演算",clientID:"5cbf8030e176bc7021bc",clientSecret:"c1a85771c8ef436e35a28f16a94de527e8a60820",repo:"linchen2chris.github.io",owner:"linchen2chris",admin:["linchen2chris"],body:decodeURI(location.href)});gitalk.render("gitalk-container")</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:lc1990linux@gmail.com class="iconfont icon-email" title=email></a><a href=https://stackoverflow.com/users/2009613/user2009613 class="iconfont icon-stack-overflow" title=stack-overflow></a><a href=https://twitter.com/chris_linchen class="iconfont icon-twitter" title=twitter></a><a href=https://www.facebook.com/chris.linchen.1 class="iconfont icon-facebook" title=facebook></a><a href=https://www.linkedin.com/in/chen-lin-945609a1/ class="iconfont icon-linkedin" title=linkedin></a><a href=http://localhost:1313 class="iconfont icon-google" title=google></a><a href=https://github.com/linchen2chris class="iconfont icon-github" title=github></a><a href=http://localhost:1313 class="iconfont icon-weibo" title=weibo></a><a href=https://www.zhihu.com/people/lin-chen-73-53 class="iconfont icon-zhihu" title=zhihu></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>site pv: <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> </span><span class=division>|</span>
<span id=busuanzi_container_site_uv>site uv: <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span></span></div><span class=copyright-year>&copy;
2016 -
2025<span class=heart><i class="iconfont icon-heart"></i></span><span></span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script><script>var languageCode="en".replace(/-/g,"_").replace(/_(.*)/,function(e,t){return e.replace(t,t.toUpperCase())});timeago().render(document.querySelectorAll(".timeago"),languageCode),timeago.cancel()</script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script><script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>